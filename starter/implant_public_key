#! /bin/sh
#######################################################################################################
#                                                                                                     #
# add an own or replace one of AVM's public keys with an own version, so we may use a (self-signed)   #
# update image again, to install our own software or execute some other commands from an 'install'    #
# script, before the device gets restarted                                                            #
#                                                                                                     #
#######################################################################################################
#                                                                                                     #
# Copyright (C) 2017-2018 P.HÃ¤mmerlein (peterpawn@yourfritz.de)                                       #
#                                                                                                     #
# This program is free software; you can redistribute it and/or modify it under the terms of the GNU  #
# General Public License as published by the Free Software Foundation; either version 2 of the        #
# License, or (at your option) any later version.                                                     #
#                                                                                                     #
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without   #
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU      #
# General Public License under http://www.gnu.org/licenses/gpl-2.0.html for more details.             #
#                                                                                                     #
#######################################################################################################
#                                                                                                     #
# This script may inject an own public key for image signature verification in two different ways.    #
#                                                                                                     #
# The first option is to create a copy of the '/etc' directory in an own tmpfs part and mount this    #
# subtree over the '/etc' directory to get a writable place, where one or more of the supported key   #
# files (avm_firmware_public_key[1-9] and plugin_global_key.pem) may be added or replaced. This way   #
# needs a huge amount of additional memory, because a complete, recursive copy of the '/etc' subtree  #
# contains up to 5 MB of data.                                                                        #
#                                                                                                     #
# The second option needs far less storage, but it has to overload one of the keys from AVM - as a    #
# result, updates can't be installed any longer, if they were signed with the - now invisible - key.  #
# Because the plugin singning key (if present) is urgently needed to bring the original plugins to    #
# run, it will never be overloaded by this script. The avm_firmware_public_key3 file is usually used  #
# to sign updates for DECT devices and other AVM accessoiries and should also kept as original.       # 
#                                                                                                     #
# So those files are ignored, while the script looks for an existing public key file, starting with   #
# an index of 9 and counting down to 1. The first file found will be overloaded, because only an      #
# existing file inode may be replaced with another one by a mount operation with option 'bind'.       #
#                                                                                                     #
# If the first approach is used, the first name of a missing public key file will be used to add the  #
# own key - it doesn't matter from the view of libfwsign.so, which file contains the key for the      #
# currently processed file. Here the plugin signing key is included in the search order - at the very #
# first position, because most firmware versions don't use an own file here and there're best chances #
# for a 'first hit'.                                                                                  #
#                                                                                                     #
# The first command line parameter selects the 'operation mode' and has to be 'replace' or 'overload' #
# for the first or second approach. Each following command line parameter is expected to be a 'big    #
# number' string with the modulus of the new public key - the exponent is always assumed to be 65537  #
# (decimal, it will be written to the file as 010001 in hexadecimal).                                 #
#                                                                                                     #
#######################################################################################################
#                                                                                                     #
# constants                                                                                           #
#                                                                                                     #
#######################################################################################################
pubkey_mask="avm_firmware_public_key%u"
pubkey_min=1
pubkey_max=9
pubkey_forbidden="3"
plugin_pubkey_mask="plugin_global_key.pem"
mode_replace="replace"
mode_overlay="overlay"
key_location="/etc"
overlay_storage="/var/flash"
possible_mountpoints="mnt filesystem var/etc"
#######################################################################################################
#                                                                                                     #
# subfunctions                                                                                        #
#                                                                                                     #
#######################################################################################################
#                                                                                                     #
# check the specified modulus for valid content and length                                            #
#                                                                                                     #
#######################################################################################################
check_modulus()
{
	local modulus="$1"
	local key_size=1024
	local bytes=$(( key_size / 8 ))
	if [ ${#modulus} -ne $(( bytes * 2 )) ]; then
		if [ "$(expr \( "$modulus" : "\(..\).*" \) )" = "00" ] && [ ${#modulus} -ne $(( ( bytes + 1 ) * 2 )) ]; then
			return 1
		fi
	fi
	if [ "$(expr \( "$modulus" : "\([0-9a-f]*\)" \) )" = "$modulus" ]; then
		return 0
	fi
	return 1
}
#######################################################################################################
#                                                                                                     #
# find the next usable key file name                                                                  #
#                                                                                                     #
#######################################################################################################
get_key_index()
{
	local exists=$1
	local index=$2
	local name
	local i
	if [ $exists -eq 0 ]; then
		if ! [ -f $key_location/$plugin_pubkey_mask ] && ! [ -h $key_location/$plugin_pubkey_mask ]; then
			printf "%u" $(( index + 1 ))
			return 0
		fi
		while [ $index -ge $pubkey_min ]; do
			name="$(printf "$pubkey_mask" $index)"
			if [ -f $key_location/$name ] || [ -h $key_location/$name ]; then
				index=$(( index - 1 ))
				continue
			fi
			printf "%u" $index
			return 0	
		done
		printf "-1"
		return 1
	else
		while [ $index -ge $pubkey_min ]; do
			name="$(printf "$pubkey_mask" $index)"
			if [ -f $key_location/$name ] && ! [ -h $key_location/$name ]; then
				printf "%u" $index
				return 0
			fi
			index=$(( index - 1 ))
			for i in $pubkey_forbidden; do
				if [ $i -eq $index ]; then
					index=$(( index - 1 ))
					break
				fi
			done
		done	
	fi
	printf "-1"
	return 1
}
#######################################################################################################
#                                                                                                     #
# check mode parameter                                                                                #
#                                                                                                     #
#######################################################################################################
mode="$1"
if [ -z "$mode" ]; then
	printf "Missing 'mode' parameter and any modulus value(s).\n" 1>&2
	exit 1
elif [ "$mode" = "$mode_replace" ] || [ "$mode" = "$mode_overlay" ]; then
	[ "$mode" = "$mode_replace" ] && overlay=0 || overlay=1
	shift
	if [ $# -eq 0 ]; then
		printf "Missing any modulus value(s) for '%s' mode.\n" "$mode" 1>&2
		exit 1
	fi
else
	printf "Invalid mode parameter '%s'.\n" "$mode" 1>&2
	exit 1
fi
#######################################################################################################
#                                                                                                     #
# prepare a tmpfs stored copy of the key location, if necessary                                       #
#                                                                                                     #
#######################################################################################################
if [ $overlay -eq 0 ]; then
	mountpoint=""
	for candidate in $possible_mountpoints; do
		if [ -d /$candidate ]; then
			mountpoint=/$candidate
			break
		fi
	done
	if [ -z "$mountpoint" ]; then
		mkdir -p /$candidate
		mountpoint=/$candidate
	fi
	mount -t tmpfs tmpfs $mountpoint
	if cp -a $key_location/* $mountpoint; then
		mount -o move $mountpoint $key_location
	else
		umount $mountpoint
		printf "Error creating a copy of key-file location '%s'.\n" "$key_location" 1>&2
		exit 1
	fi
fi
#######################################################################################################
#                                                                                                     #
# loop over all remaining parameters                                                                  #
#                                                                                                     #
#######################################################################################################
key_index=$pubkey_max
while [ $# -gt 0 ]; do
	modulus="$1"
	shift
	if check_modulus "$modulus"; then
		key_index=$(get_key_index $overlay $key_index)
		if [ $key_index -lt 0 ]; then
			printf "Unable to find a usable key file name.\n" 1>&2
			exit 1
		else
			if [ $key_index -gt $pubkey_max ]; then
				key_name="$plugin_pubkey_mask"
			else
				key_name="$(printf "$pubkey_mask" $key_index)"
			fi
			file_name=$key_location/$key_name
			if [ $overlay -eq 1 ]; then
				touch $overlay_storage/$key_name
				mount -o bind $overlay_storage/$key_name $file_name
			fi
			printf "%s\n010001\n" "$modulus" >$file_name
			printf "Installed public key to file '%s'.\n" $key_name
			key_index=$(( key_index - 1 ))
		fi
	else
		printf "Invalid modulus content or length, this one was skipped.\n" 1>&2
	fi	
done
#######################################################################################################
#                                                                                                     #
# finish and regular exit                                                                             #
#                                                                                                     #
#######################################################################################################
exit 0
#######################################################################################################
#                                                                                                     #
# end of script                                                                                       #
#                                                                                                     #
#######################################################################################################
