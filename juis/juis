#! /bin/sh
# vim: set tabstop=4 syntax=sh :
#######################################################################################################
#                                                                                                     #
# check firmware versions from AVM's JUIS                                                             #
#                                                                                                     #
###################################################################################################VER#
#                                                                                                     #
# juis_check, version 0.3                                                                             #
#                                                                                                     #
# This script is a part of the YourFritz project from https://github.com/PeterPawn/YourFritz.         #
#                                                                                                     #
###################################################################################################CPY#
#                                                                                                     #
# Copyright (C) 2010-2018 P.Haemmerlein (peterpawn@yourfritz.de)                                      #
#                                                                                                     #
###################################################################################################LIC#
#                                                                                                     #
# This project is free software, you can redistribute it and/or modify it under the terms of the GNU  #
# General Public License as published by the Free Software Foundation; either version 2 of the        #
# License, or (at your option) any later version.                                                     #
#                                                                                                     #
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without   #
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU      #
# General Public License under http://www.gnu.org/licenses/gpl-2.0.html for more details.             #
#                                                                                                     #
#######################################################################################################
#                                                                                                     #
# This is another rewritten version ... the original script gots more attention than ever expected    #
# and is used in different environments. To make it more flexible, it's now able to run under a bunch #
# of shell hosts, from 'bash' over BusyBox' 'ash' to the very limited 'dash' from Debian based        #
# distributions.                                                                                      #
#                                                                                                     #
# As long as a 'bash' host is used, the network communication is done via the integrated TCP/UDP      #
# support. In all other cases, a 'netcat' version is needed (reachable via the command name 'nc') to  #
# handle network I/O.                                                                                 #
#                                                                                                     #
# Each other command used within this script, should be available on each *nix-based system, from a   #
# native Linux installation (Desktop, Embedded, One-Chip like RasPi) over a BSD-like system (e.g.     #
# MacOS X) up to Canonical's 'bash' on Windows 10 installations.                                      #                                                                              
#                                                                                                     #
#######################################################################################################
usage_text()
{
	if [ $__language__ = de ]; then
		__purpose_hdr
		__nl "Die deutsche Version ist noch nicht fertig, Hilfe gibt es mit\n"
		__nl "LC_ALL=en_US $0 --help"
	else
		__purpose_hdr
		__nl "This script may be used to query AVM's update information service (JUIS) for new versions.\n"
		__nl "Due to the ability to configure many (or most) parameters of such a query manually, it is"
		__nl "possible to look for fresh firmware for nearly all AVM devices.\n"
		__nl "Nevertheless it's still possible to call the script only with the IP address of an existing"
		__nl "(and locally reachable) FRITZ!OS-based router - then it simply will try to get all needed"
		__nl "parameters for the query from this device.\n"
		__nl "So it's still as easy as possible to look regularly, if a new firmware for your \"beloved"
		__nl "router\" was published meanwhile - even from outside of this device and if you want to avoid"
		__nl "any automatic discovery and installation of newer firmware versions, e.g. due to (reasonable)"
		__nl "security concerns."
		__usage_hdr
		__usage_opt "options"; __usage_opt_end; __usage_opt "optional parameters"
		__usage_end
		__options_hdr
		__option_debug 24
		__option_help 24
		__option_version 24
		__options_end
		__nl "The script attempts to read a configuration file with its own name (or better expressed:"
		__nl "with the name, that was used to call it, because this may be a symbolic link, too) from"
		__nl "the same location, where the script itself was found. This file will be \"included\" with a"
		__nl "'.' (dot) command and may contain any shell statement - please be aware, that this may lead"
		__nl "to a severe security threat, if anyone else may modify this file without your knowledge.\n"
		__nl "To use another file instead, add a value named 'JUIS_CHECK_CFG', containing the name of a"
		__nl "configuration file, to the environment of this script.\n"
		__nl "This configuration file may be used to set one or more of the needed settings (see below)"
		__nl "from positional parameters on the command line and has to use the \"shift\" statement to"
		__nl "remove any processed entries from the parameters collection.\n"
		__nl "Any remaining values from command line are expected to be a name/value pair for one of the"
		__nl "following known settings:\n"
		__nl "$(__bold "name        meaning\n")"
		__nl "Version     the firmware version to be assumed as the currently running one - this is the"
		__nl "            combined version string, which overrules any of the following partial values:"
		__nl "-----------------------------------------------------------------------------------------------"
		__nl "Major       model-specific firmware version, usually it's 'HW' minus 72, someone has told me"
		__nl "Minor       main version number of FRITZ!OS"
		__nl "Patch       second part of version number"
		__nl "Buildnumber an incrementing value, presumably the consecutive number for a whole build process,"
		__nl "            it's called 'Revision' in older firmware (and in the 'jason_boxinfo.xml' file)"
		__nl "-----------------------------------------------------------------------------------------------"
		__nl "Serial      the serial number of the FRITZ!Box device (usually the same as \"maca\")"
		__nl "Name        the product name"
		__nl "HW          the hardware revision"
		__nl "OEM         the OEM value used (also known as the \"branding\")"
		__nl "Lang        the current language set"
		__nl "Annex       the used annex for the DSL modem or \"Kabel\" for DOCSIS devices"
		__nl "Country     the ITU recommended country code (E.164)"
		__nl "Flag        a comma-delimited list of flags to be included into the request"
		__nl "-----------------------------------------------------------------------------------------------"
		__nl "Public      '1' to check only for public versions, '0' to accept 'inhouse builds' instead\n"
		__nl "The values for 'Major', 'Minor', 'Patch' and 'Buildnumber' may not be set from the command"
		__nl "line, only from a configuration file. If you want to set a different version number while"
		__nl "calling the script, use positional parameters with an appropriate configuration file or use"
		__nl "the compound value 'Version' to specify all parts at once.\n"
		__nl "If any of the above values isn't set after the configuration file was processed, the 'Box'"
		__nl "value has to be present - either containing an IP address or a DNS name of a FRITZ!Box"
		__nl "device, which will be accessed to retrieve missing values. Only if all of the values above"
		__nl "are already present, this read attempt will be skipped and the 'Box' value will be ignored.\n"
		__nl "If no configuration file was found, a file containing the lines:\n"
		__nl "Box=\$1"
		__nl "shift\n"
		__nl "is assumed instead - this means, the script expects the name or address of a FRITZ!OS device"
		__nl "as first (and only) parameter and tries to read all other settings from the specified device.\n"
		__nl "Each setting may be specified with the keyword \"detect\" (it has the same meaning as a missing"
		__nl "entry), a setting with this state will be read from the FRITZ!OS device. If the keyword \"empty\""
		__nl "is used, the parameter will be set to an empty string, but is seen as \"present\" and not read"
		__nl "from the device. If the keyword \"fixed:\" is used at the beginning of the value (or if any"
		__nl "other keyword is absent), the string after the colon is used as value. If you want to use a"
		__nl "parameter starting with the string \"detect\", you have to use \"fixed:detect\" to specify it"
		__nl "in the right way.\n"
		__nl "If you need to specify a setting with a value, which contains characters from the IFS value"
		__nl "(it's used for field splitting from POSIX-compatible shells), it may be a bit tricky ... the"
		__nl "value will be used in an 'eval' statement somewhere in the script and you have to escape such"
		__nl "characters with double-backslashes in the value - e.g. you have to use this line:\n"
		__nl "Name=\"FRITZ!Box\\\\\\ 7490\"\n"
		__nl "to get a single space in the final request."
	fi
}
#######################################################################################################
#                                                                                                     #
# L10N strings                                                                                        #
#                                                                                                     #
#######################################################################################################
languages="en de"
L10N_DBG_001_en="Reading and interpreting configuration file '%%s' with content:\\\\n"
L10N_DBG_001_de="Verarbeiten der Konfigurationsdatei '%%s' mit folgendem Inhalt:\\\\n"
L10N_DBG_002_en="Configuration file processing finished.\\\\n"
L10N_DBG_002_de="Ende der Verarbeitung der Konfigurationsdatei\\\\n"
L10N_DBG_003_en="Variables set:\\\\n"
L10N_DBG_003_de="Werte der Variablen:\\\\n"
L10N_DBG_004_en="Sent request:\\\\n"
L10N_DBG_004_de="Gesendete Abfrage:\\\\n"
L10N_DBG_005_en="Received response:\\\\n"
L10N_DBG_005_de="Empfangene Antwort:\\\\n"
L10N_DBG_006_en="Reading values from '%%s:%%s/%%s': "
L10N_DBG_006_de="Lesen der Parameter von '%%s:%%s/%%s': "
L10N_DBG_007_en="Read response from device:\\\\n"
L10N_DBG_007_de="Antwort vom Gerät:\\\\n"
L10N_DBG_008_en="Reading response from '%%s:%%s': "
L10N_DBG_008_de="Lesen der Antwort von '%%s:%%s': "
L10N_DBG_009_en="Setting '%%s' to '%%s' from command line parameter\\\\n"
L10N_DBG_009_de="Setzen des Parameters '%%s' auf '%%s' entsprechend der Angabe auf der Kommandozeile\\\\n"
L10N_DBG_010_en="Splitting compound version number '%%s' to:\\\\n"
L10N_DBG_010_de="Zerlegen der zusammengesetzten Versionsnummer '%%s' in die Teile:\\\\n"
L10N_ERR_001_en="Missing configuration file and first parameter (the IP address of a reachable FRITZ!Box) at the same time."
L10N_ERR_001_de="Die Konfigurationsdatei wurde nicht gefunden und gleichzeitig fehlt der erste Parameter (die IP-Adresse der FRITZ!Box) beim Aufruf."
L10N_ERR_002_en="Missing FRITZ!Box IP address or DNS name."
L10N_ERR_002_de="Die IP-Adresse oder der DNS-Name der FRITZ!Box fehlt in den Parametern."
L10N_ERR_003_en="Error reading '%%s' from FRITZ!Box device with address '%%s:%%s'."
L10N_ERR_003_de="Fehler beim Lesen der Geräteparameter (%%s) von der FRITZ!Box mit der Adresse '%%s:%%s'."
L10N_ERR_004_en="'%%s' item may only be empty or set to a fixed boolean value."
L10N_ERR_004_de="Der Wert für '%%s' muß leer sein oder fest auf '0' oder '1' (bzw. 'false' oder 'true') gesetzt werden."
L10N_ERR_005_en="Unknown setting '%%s' found at command line."
L10N_ERR_005_de="Der Parameter '%%s' ist unbekannt."
L10N_ERR_006_en="The '%%s' item has to be set to '0' for 'inhouse versions' or '1' for others."
L10N_ERR_006_de="Der Wert für '%%s' kann nur '0' für die Suche nach internen Versionen sein, ansonsten ist '1' die einzige gültige Alternative und auch gleichzeitig der Standardwert."
L10N_ERR_007_en="Unexpected data received from network."
L10N_ERR_007_de="Es wurden Daten mit einem unerwarteten Format empfangen vom Server."
L10N_ERR_008_en="Unexpected error code %s returned from %s."
L10N_ERR_008_de="Es wurde ein unerwarteter Statuscode (%%s) von %%s gesendet."
L10N_ERR_009_en="No newer version found, check was made with source version '%%s'."
L10N_ERR_009_de="Es wurde keine neue Version gefunden, die Prüfung erfolgte ausgehend von der Version '%%s'."
L10N_ERR_010_en="Missing 'procfs' mounted on '/proc'."
L10N_ERR_010_de="Unter '/proc' muss ein 'procfs' verfügbar sein für die korrekte Funktion dieses Skripts."
L10N_ERR_011_en="Missing '/dev/urandom' node, pointing to a random number generator."
L10N_ERR_011_de="Die Datei '/dev/urandom' muß auf eine passende Quelle für Zufallszahlen zeigen."
L10N_INF_001_en="Found newer version: %%s"
L10N_INF_001_de="Neue Version gefunden: %%s"
#######################################################################################################
#                                                                                                     #
# usage and display helpers from YourFritz framework (included to get a single file to copy/install)  #
#                                                                                                     #
#######################################################################################################
__bold__="$(printf "\033[1m")"
__undl__="$(printf "\033[4m")"
__red__="$(printf "\033[1m\033[31m")"
__gren__="$(printf "\033[1m\033[32m")"
__yllw__="$(printf "\033[1m\033[33m")"
__blue__="$(printf "\033[1m\033[34m")"
__rset__="$(printf "\033[0m")"
__bold() { printf "$__bold__"; printf -- "$@"; printf "$__rset__"; }
__undl() { printf "$__undl__"; printf -- "$@"; printf "$__rset__"; }
__show_script_name()
{
	printf "%s${0#*/}\033[0m: " "$1"
}
__get_script_lines()
{
	sed -n -e "/^#*${1}#\$/,/^#\{20\}.*#\$/p" "$0" | \
	sed -e '1d;$d' | \
	sed -e 's|# \(.*\) *#$|\1|' | \
	sed -e 's|^#*#$|--|p' | \
	sed -e '$d'
}
__license()
{
	__get_script_lines "LIC"
}
__version()
{
	__get_script_lines "VER" | sed -e "1,2s|^\([^,]*\),\(.*\)\$|$__bold__\1$__rset__,\2|"
}
__copyright()
{
	__get_script_lines "CPY"
}
__get_language()
{
	__get_language_code()
	{
		printf "%s\n" "$1" | sed -n -e "s|^\([A-Za-z]*\).*|\1|p" | sed -e "y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/"
	}
	local lang="$1"
	shift
	local check
	local l
	if ! [ -z "$LC_ALL" ]; then
		check=$(__get_language_code "$LC_ALL")
	else
		[ -z "$LANG" ] || check=$(__get_language_code "$LANG")
	fi
	if ! [ -z "$check" ]; then
		[ "$lang" = "$check" ] || \
		for l in $*; do
			[ "$l" = "$check" ] && lang="$l" && break
		done
	fi
	printf "%s" "$lang"
}
__language__="$(eval __get_language $languages)"
__get_localized()
{
	eval printf "\"\$L10N_${1}_${__language__}\""	
}
__emsg()
{
	__show_script_name "$__red__" 1>&2
	mask="$1"
	shift
	printf "${__bold__}${mask}${__rset__}\a\n" "$@" 1>&2
}
__info()
{
	__show_script_name "$__gren__" 1>&2
	mask="$1"
	shift
	printf "${__bold__}${mask}${__rset__}\n" "$@" 1>&2
}
__check_option()
{
	o="$1"
	shift
	for v in $*; do
		[ "$o" = "$v" ] && printf 1 && return 0
	done
	printf 0
	return 1
}
__is_option()
{
	[ "$(expr \( "$1" : "\(.\).*" \) )" = "-" ] && return 0 || return 1
}
__is_last_option()
{
	[ "$1" = "--" ] && return 0 || return 1
}
__options_end__="eval while __is_option \"\$1\"; do __is_last_option \"\$1\" && shift && break;\
	__emsg \"Unknown option '%s'.\" \"\$1\"; exit 1; done;"
__version_option()
{
	if __check_option "$1" "-V" "--version" >/dev/null; then
		__version
		__copyright
		__license
		printf "\n"
		exit 1
	fi
	return 1
}
__version_option__="eval __version_option \$@ && exit 0"
__help_option()
{
	if __check_option "$1" "-h" "--help" >/dev/null; then
		__usage
		exit 1
	fi
}
__help_option__="eval __help_option \$@"
__debug_option()
{
	__check_option "$1" "-d" "--debug" && return 0
	return 1
}
__debug_option__="eval __debug_set__=\$(__debug_option \$1) && __debug_text__=\"\$1\" && shift"
__debug_on__="eval __debug_set__=1; __debug_text__=\"-d\";"
__is_debug() { [ $__debug_set__ -eq 1 ] && return 0 || return 1; }
__debug()
{
	[ $__debug_set__ -eq 1 ] || return;
	mask="$1"
	shift
	printf "%sdebug%s: " "$__yllw__" "$__rset__" 1>&2
	printf -- "$mask" "$@" 1>&2
}
__usage()
(
	indent=0
	__indent_on() { indent=$(( indent + 4 )); }
	__indent_off() { indent=$(( indent - 4 )); }
	__indent() { [ $indent -gt 0 ] && printf "%0${indent}s" " "; };
	__nl() { printf "\n%s" "$(__indent)"; printf -- "$1"; }
	__purpose_hdr() { __nl; __bold "Purpose:"; printf "\n"; }
	__usage_name() { __bold "${0#*/}"; }
	__usage_hdr() { printf "\n"; __nl; __bold "Usage:\n"; __indent_on; __nl "$(__usage_name)"; }
	__usage_end() { __indent_off; printf "\n"; }
	__usage_opt_int() { v="$1"; shift; [ $# ] && m="$@"; printf -- "[ %s%s ]" "$(__undl "$v")" "$m"; unset m v; };
	__usage_opt_end() { printf -- " [ -- ]"; }
	__usage_opt() { printf -- " %s" "$(__usage_opt_int "$@")"; }
	__usage_arg() { printf -- " %s" "$(__undl "$1")"; }
	__options_hdr() { __nl "Supported "; __undl "options"; printf " are:\n"; }
	__options_end() { printf "\n"; }
	__option_show_opt() {
		printf -- "%s, %s" "$2" "$3"
		__l4__=${#4}
		[ $__l4__ -gt 0 ] && printf " %s%s%s" "$__undl__" "$4" "$__rset__" && __l4__=$(( __l4__ + 1 ))
		printf "%0$(( $1 - ${#2} - ${#3} - __l4__ - 3 ))s" " "
		unset __l4__
	}
	__option_show_desc() { printf -- "- %s" "$@"; }
	__option_debug() { __nl; __option_show_opt ${1:-15} "-d" "--debug"; __option_show_desc "display debug info on STDERR; must prefix all other options, if used"; }
	__option_help()	{ __nl; __option_show_opt ${1:-15} "-h" "--help"; __option_show_desc "show this information (must be the first option)"; }
	__option_version()	{ __nl; __option_show_opt ${1:-15} "-V" "--version"; __option_show_desc "show version and exit (must be the first option)"; }
	__end() { printf "\n%s\n" "$__rset__"; }

	__version
	__copyright
	__license
	usage_text
	__end
)
__set_base_dir__="eval [ \"\$(expr \"\$0\" : \".*\(/\).*\")\" = \"/\" ] && __base_dir__=\"\${0%/*}\" || __base_dir__=\".\""
__set_base_dir() { __set_base_dir__="$1"; }
__check_required_scripts()
{
	d="$1"
	shift
	for n in $@; do
		eval $n="$d/$n"
		eval f="\$$n"
		if ! [ -x "$f" ]; then
			__emsg "Missing another needed executable: %s." "$n"
			return 1
		fi
		printf "$n=%s\n" $f
	done
	return 0
}
__check_required_scripts__="eval __scripts__=\"\$(__check_required_scripts \"\$__base_dir__\" \"\$__required_scripts\")\" && \
	eval \$__scripts__ || exit 1"
__check_required_commands()
{
	for n in $@; do
		command -v $n 2>/dev/null 1>&2 && continue
		__emsg "Missing a required command: %s." "$n"
		return 1
	done
	return 0
}
__check_required_commands__="eval __check_required_commands \"\$__required_commands\" || exit 1"
__check_terminal()
{
	[ -t $1 ] || return 1
	if [ $1 -eq 0 ]; then
		fd="STDIN"
	elif [ $1 -eq 1 ]; then
		fd="STDOUT"
	else
		fd="FILE ($1)"
	fi
	shift
	__emsg "%s is a terminal device. %s" "$fd" "$@"
}

__required_commands="sed base64 dd mknod cat rm mkdir touch stat"
__required_scripts=""
#######################################################################################################
#                                                                                                     #
# check parameters                                                                                    #
#                                                                                                     #
#######################################################################################################
$__help_option__
$__version_option__
$__debug_option__
while [ $# -gt 0 ]; do
	__is_option "$1" || break
	__is_last_option "$1" && shift && break
	__emsg "Unknown option '%s'." "$1" && exit 1
done
#######################################################################################################
#                                                                                                     #
# check environment                                                                                   #
#                                                                                                     #
#######################################################################################################
$__set_base_dir__
$__check_required_commands__
#$__check_required_scripts__
if ! [ -d /proc/$$ ]; then
	__emsg "$(__get_localized ERR_010)"
	exit 1
fi
if ! [ -c /dev/urandom ]; then
	__emsg "$(__get_localized ERR_011)"
	exit 1
fi
#######################################################################################################
#                                                                                                     #
# constants                                                                                           #
#                                                                                                     #
#######################################################################################################
# common property names
common_names="Serial Name HW OEM Lang Annex Country"
# properties with different names
version_name="Version"
buildnumber_name="Buildnumber"
version_parts="%Major%.%Minor%.%Patch%[-%Buildnumber%]"
version_compound="\$Version-\$Buildnumber"
version_string="\$(printf "%d.%02d.%02d-%s" \$Major \$Minor \$Patch \$$buildnumber_name)"
boxinfo1_replace_names=""
boxinfo2_replace_names="Revision:Buildnumber"
alt_names="$version_name:Major $version_name:Minor $version_name:Patch $version_name:$buildnumber_name"
# flag option name, may contain more than one value (delimited by comma), will be splitted to multiple XML entities
flags_name="Flag"
# special 'boolean' option, usable to retrieve internal updates from AVM' servers, if they're published 
# via JUIS - finally it modifies the 'buildtype' parameter of our SOAP request
# name and meaning are a little bit confusing, but really 'true' or 'false' in shell syntax  ... a value 
# of "1" means "no inhouse version" (or 'inhouse=false') and "0" searches for non-public versions
inhouse_option_name="Public"
# local file retrieval constants
boxport=80
boxinfo1="juis_boxinfo.xml"
boxinfo2="jason_boxinfo.xml"
local_timeout=10
# SOAP request constants
hostbase="jws.avm.de"
#hostbase="fritz.box"
juisport=80
juisurl="/Jason/UpdateInfoService"
remote_timeout=20
# HTTP header related constants
headerline_0="POST %s HTTP/1.1\r\n"
headerline_1="Host: %s:%u\r\n"
headerline_2="Content-Length: %u\r\n"
headerline_3="Content-Type: %s\r\n"
headerline_4="Connection: close\r\n"
contenttype="text/xml; charset=\"utf-8\""
# SOAP request body, will be constructed on-the-fly in the next version
body_tmpl="\
<soap:Envelope xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:soap-enc=\"http://schemas.xmlsoap.org/soap/encoding/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:e=\"http://juis.avm.de/updateinfo\" xmlns:q=\"http://juis.avm.de/request\">\n\
  <soap:Header/>\n\
  <soap:Body>\n\
    <e:BoxFirmwareUpdateCheck>\n\
      <e:RequestHeader>\n\
        <q:Nonce>%s</q:Nonce>\n\
        <q:UserAgent>Box</q:UserAgent>\n\
        <q:ManualRequest>true</q:ManualRequest>\n\
      </e:RequestHeader>\n\
      <e:BoxInfo>\n\
        <q:Name>%s</q:Name>\n\
        <q:HW>%s</q:HW>\n\
        <q:Major>%s</q:Major>\n\
        <q:Minor>%s</q:Minor>\n\
        <q:Patch>%s</q:Patch>\n\
        <q:Buildnumber>%s</q:Buildnumber>\n\
        <q:Buildtype>%s</q:Buildtype>\n\
        <q:Serial>%s</q:Serial>\n\
        <q:OEM>%s</q:OEM>\n\
        <q:Lang>%s</q:Lang>\n\
        <q:Country>%s</q:Country>\n\
        <q:Annex>%s</q:Annex>\n\
        <q:Flag>%s</q:Flag>\n\
        <q:UpdateConfig>1</q:UpdateConfig>\n\
        <q:Provider>oma_lan</q:Provider>\n\
      </e:BoxInfo>\n\
    </e:BoxFirmwareUpdateCheck>\n\
  </soap:Body>\n\
</soap:Envelope>\n\
"
# debug log delimiter line for easier reading
delimiter_line="-------------------------------------------------------\n"
#######################################################################################################
#                                                                                                     #
# subfunctions                                                                                        #
#                                                                                                     #
#######################################################################################################
#                                                                                                     #
# read data from a TCP connection - use native /dev/tcp, if we're running from a 'bash' instance or   #
# use a 'netcat' version (called with 'nc') for any other host shell                                  #
#                                                                                                     #
#######################################################################################################
tcp_read()
{
#	if [ -z "$BASH_VERSION" ]; then
		run_nc $1 $2 "$3" $4
#	fi
}
#######################################################################################################
#                                                                                                     #
# run 'nc' applet/command                                                                             #
#                                                                                                     #
#######################################################################################################
run_nc()
{
	local hostname="$1"
	local port="$2"
	local out="$3"
	local timeout="$4"
	local pin="$(mktmp -p "$td")"
	local i=0
	local ncpid
	exec 7>&2
	exec 2>/dev/null
	rm "$pin"
	mknod "$pin" p
	exec 6<>"$pin"
	nc "$hostname" "$port" >"$out" <"$pin" &
	ncpid=$!
	cat - 1>&6
	while ! [ -s "$out" ] && [ -d /proc/$ncpid ]; do
		i=$(( i + 1 ))
		__is_debug && printf "." 1>&7
		[ $i -gt $timeout ] && break
		sleep 1
	done
	__is_debug && printf "\n" 1>&7
	sleep 1
	exec 6>&-
	sleep 1
	[ -d /proc/$ncpid ] && kill $ncpid
	rm "$pin" 2>/dev/null
	exec 2>&7
}
#######################################################################################################
#                                                                                                     #
# extract result variables from XML answer                                                            #
#                                                                                                     #
#######################################################################################################
extract_xml()
{
	local input="$1"
	local ns="$2"
	local tag="$3"
	sed -n -e "s|.*<$ns:$tag>\(.*\)</$ns:$tag>.*|\1|p" $input
}
#######################################################################################################
#                                                                                                     #
# read device parameters from a FRITZ!Box                                                             #
#                                                                                                     #
#######################################################################################################
device_read()
{
	local ip="$1"
	local port="$2"
	local file="$3"
	local out="$(mktmp -p "$td")"
	local rc
	local answer
	__debug "$delimiter_line"
	__debug "$(__get_localized DBG_006)" "$ip" "$port" "$file"
	printf "GET /%s HTTP/1.0\r\n\r\n" "$file" | tcp_read "$ip" "$port" "$out" $local_timeout
	if [ -s "$out" ]; then
		if __is_debug; then
			__debug "$(__get_localized DBG_007)"
			__debug "$delimiter_line"
			sed -e "s|^|       |" "$out" 1>&2
			printf "\n" 1>&2
		fi
		answer="$(sed -n -e "1p" "$out")"
		if [ "$(expr \( "$answer" : ".*\(200 OK\).*" \) )" = "200 OK" ]; then
			cat "$out"
			rc=0
		else
			rc=1
		fi
	else
		rc=1
	fi
	rm "$out" 2>/dev/null
	return $rc
}
#######################################################################################################
#                                                                                                     #
# make temporary directory or file, emulate 'mktemp' if it's missing                                  #
#                                                                                                     #
#######################################################################################################
mktmp()
{
	local name="$(mktemp $* 2>/dev/null)"
	if [ $? -eq 127 ] || [ -z $name ]; then 
		# mktemp is missing, emulation needed
		local dir 
		local tmp="$TMPDIR"
		[ "$1" = "-d" ] && dir=1 || dir=0
		[ "$1" = "-p" ] && tmp="$2"
		[ -z "$tmp" ] && tmp="/tmp"
		name="$tmp/$(date +%s)_$$"
		if [ $dir -eq 1 ]; then
			[ -d "$name" ] && name="${name}_$(sleep 1; date +%s)"
			mkdir -p "$name" 2>/dev/null
		else
			touch "$name" 2>/dev/null
		fi
	fi
	printf "$name"
}
#######################################################################################################
#                                                                                                     #
# build a string with each valid variable name                                                        #
#                                                                                                     #
#######################################################################################################
get_names()
{
	local l_names="$1"
	local p
	local i=$3
	local l
	local n
	for n in $2; do
		p=$(IFS=:; set -- $n; eval printf "%s" "\$${i}")
		l_names="$l_names $p"
	done
	l_names="$l_names"
	for n in $l_names; do
		[ "$n" = "$last" ] && continue
		printf " %s" "$n"
		last="$n"
	done
}
#######################################################################################################
#                                                                                                     #
# replace occurences of a template with another string in a file                                      #
#                                                                                                     #
#######################################################################################################
replace_in_file()
{
	local file="$1"
	local t="$2"
	local r="$3"
	local tmp="$(mktmp -p "$td")"
	cat "$file" >"$tmp"
	sed -e "s|$t|$r|g" "$tmp" >"$file"
	rm "$tmp" 2>/dev/null
}
#######################################################################################################
#                                                                                                     #
# split old style version number into parts with the new names                                        #
#                                                                                                     #
#######################################################################################################
split_version_number()
{
	__first_char()
	{
		expr \( "$1" : "\(.\).*" \)
	}
	__remove_first_char()
	{
		expr \( "$1" : ".\(.*\)" \)
	}
	local v="$1"
	local m="$version_parts"
	local c
	local n
	local s=0
	local o
	local e
	while [ ${#v} -gt 0 ]; do
		c="$(__first_char "$m")"
		m="$(__remove_first_char "$m")"
		if [ "$c" = "%" ]; then
			if [ $s -eq 0 ]; then
				s=1
				n=""
			else
				s=0
			fi
		elif [ -z "$(expr \( "$c" : "\([A-Za-z]\)" \) )" ]; then
			if [ "$c" = "[" ]; then
				o=1
			elif [ "$c" = "]" ]; then
				o=0
			else
				printf "%s=" "$n"
				until [ ${#v} -eq 0 ]; do
					e="$(__first_char "$v")"
					v="$(__remove_first_char "$v")"
					[ "$e" = "$c" ] && printf "\n" && break
					printf "%s" "$e"
				done
				[ ${#v} -eq 0 ] && printf "\n"
			fi
		else
			n="$n$c"
		fi
	done
}
#######################################################################################################
#                                                                                                     #
# now it's time to do something useful                                                                #
#                                                                                                     #
#######################################################################################################
#                                                                                                     #
# prepare temporary directory and cleanup on exit                                                     #
#                                                                                                     #
#######################################################################################################
td="$(mktmp -d)"
trap 'rm -rf "$td" 2>/dev/null' EXIT INT HUP
#######################################################################################################
#                                                                                                     #
# let's determine, which configuration file has to be used                                            #
#                                                                                                     #
#######################################################################################################
[ -z "$JUIS_CHECK_CFG" ] && cfg="${0}.cfg" || cfg="$JUIS_CHECK_CFG"
#######################################################################################################
#                                                                                                     #
# process configuration file                                                                          #
#                                                                                                     #
#######################################################################################################
if [ -f "$cfg" ]; then
	if __is_debug; then
		__debug "$(__get_localized DBG_001)" "$(realpath "$cfg")"
		__debug "$delimiter_line"
		sed -e "\${/^\$/d}" "$cfg" | sed -e "s|^|       |" 1>&2
		__debug "$delimiter_line"
	fi
	. "$cfg"
	__debug "$(__get_localized DBG_002)" 
else
	if [ -z "$1" ]; then
		__emsg "$(__get_localized ERR_001)"
		exit 1
	fi
	Box="$1"
	shift
fi
# we use the older variant with a 'Version' value here to retain backward compatibility
names="$(get_names "$common_names" "$alt_names" 1) $flags_name $inhouse_option_name"
#######################################################################################################
#                                                                                                     #
# first attempt to process name/value pairs from command line, to set variables without an existing   #
# device                                                                                              #
#                                                                                                     #
#######################################################################################################
for nv in $*; do
	name="${nv%%=*}"
	value="${nv#*=}"
	valid=0
	for n in $names; do
		if [ "$n" = "$name" ]; then
			__debug "$(__get_localized DBG_009)" "$n" "$value"
			if [ "$value" = "empty" ]; then
				eval $n=''
			else
				eval $n=\'$value\'
			fi
			valid=1
			break
		fi
	done
	if [ $valid -eq 1 ] && [ "$name" = "$version_name" ]; then
		spl="$(mktmp -p "$td")"
		split_version_number "$value" >"$spl"
		. "$spl"
		rm "$spl" 2>/dev/null
	fi
done
#######################################################################################################
#                                                                                                     #
# check still missing variables, after the configuration file and command line were processed         #
#                                                                                                     #
#######################################################################################################
detect=0
for n in $names; do
	[ "$n" = "$inhouse_option_name" ] && continue
	eval var="\$$n"
	if [ -z "$var" ] || [ "$var" = "detect" ]; then
		detect=1
		break
	fi
done
#######################################################################################################
#                                                                                                     #
# read variables from device, if needed                                                               #
#                                                                                                     #
#######################################################################################################
if [ $detect -eq 1 ]; then
	if [ -z "$Box" ]; then
		__emsg "$(__get_localized ERR_002)"
		exit 1
	fi
	boxinfo="$(mktmp -p "$td")"
	device_read "$Box" "$boxport" "$boxinfo1" >"$boxinfo"
	if [ $? -ne 0 ]; then
		__debug "$(__get_localized ERR_003)\n" "$boxinfo1" "$Box" "$boxport"
		device_read "$Box" "$boxport" "$boxinfo2" >"$boxinfo"
		if [ $? -ne 0 ]; then
			__emsg "$(__get_localized ERR_003)" "$boxinfo2" "$Box" "$boxport"
		else
			names="$(get_names "$common_names" "$alt_names" 1) $flags_name $inhouse_option_name"
			ns="j"
			replace="$boxinfo2_replace_names"
		fi
	else
		names="$(get_names "$common_names" "$alt_names" 2) $flags_name $inhouse_option_name"
		ns="q"
		replace="$boxinfo1_replace_names"
	fi
	if ! [ -z "$replace" ]; then
		for v in $replace; do
			l=$(expr \( "$v" : "\([^:]*\):.*" \) )
			r=$(expr \( "$v" : "[^:]*:\(.*\)" \) )
			replace_in_file "$boxinfo" "$ns:$l" "$ns:$r"
		done
	fi
fi
#######################################################################################################
#                                                                                                     #
# set missing variables from the read data                                                            #
#                                                                                                     #
#######################################################################################################
for n in $names; do
	eval var="\$$n"
	if [ "$var" = "empty" ]; then
		[ "$n" = "$inhouse_option_name" ] && eval ${inhouse_option_name}=1 || eval $n=""
	elif ! [ "${var#fixed:}" = "$var" ]; then
		eval $n="${var#fixed:}"
	elif [ "$n" = "$inhouse_option_name" ]; then
		if ! [ -z "$var" ]; then
			d="$(printf -- "%s\n" "$var" | sed -e "y/AEFLRSTU/aeflrstu/")"
			[ "$(printf -- "%s\n" "$var" | sed -n -e "s|^false\$|0|p")" = "0" ] && var=0
			[ "$var" = "0" ] || [ "$(printf -- "%s\n" "$var" | sed -n -e "s|^true\$|1|p")" = "1" ] && var=1
			if ! [ "$var" = "0" ] && ! [ "$var" = "1" ]; then
				__emsg "$(get_localized ERR_004)" "$inhouse_option_name"
				exit 1
			else
				eval $inhouse_option_name=$var
			fi
		else
			eval $inhouse_option_name=1
		fi
	elif [ -z "$var" ] || [ "$var" = "detect" ]; then
		val="$(extract_xml "$boxinfo" "$ns" $n)"
		eval $n=\'$val\'
		if [ "$n" = "$version_name" ]; then
			eval $buildnumber_name="\$(extract_xml "$boxinfo" "$ns" "$buildnumber_name")"
			eval $n="$version_compound"
			value="$(eval printf "%s" "\$$n")"
			__debug "$(__get_localized DBG_010)" "$value"
			spl="$(mktmp -p "$td")"
			split_version_number "$value" >"$spl"
			cat "$spl" | \
			while read line; do
				__debug "%s\n" "$line"
			done
			. "$spl"
			rm "$spl" 2>/dev/null
		fi
	else
		eval $n=\'$var\'
	fi
done
#######################################################################################################
#                                                                                                     #
# process additional command line settings again, they overrule all other values                      #
#                                                                                                     #
#######################################################################################################
for nv in $*; do
	name="${nv%%=*}"
	value="${nv#*=}"
	valid=0
	for n in $names; do
		if [ "$n" = "$name" ]; then
			if [ "$value" = "empty" ]; then
				eval $n=''
			else
				eval $n=\'$value\'
			fi
			valid=1
			if [ "$n" = "$version_name" ]; then
				# old style version number found, we have to split it
				__debug "$(__get_localized DBG_010)" "$value"
				spl="$(mktmp -p "$td")"
				split_version_number "$value" >"$spl"
				cat "$spl" | \
				while read line; do
					__debug "%s\n" "$line"
				done
				. "$spl"
				rm "$spl" 2>/dev/null
			fi
			break
		fi
	done
	if [ $valid -eq 0 ]; then
		__emsg "$(__get_localized ERR_005)" "$name"
		exit 1
	fi
done
#######################################################################################################
#                                                                                                     #
# prepare additional variables                                                                        #
#                                                                                                     #
#######################################################################################################
[ -z "$(eval printf "%s" "\$$inhouse_option_name")" ] && eval $inhouse_option_name=1
if ! [ "$(eval printf "%s" "\$$inhouse_option_name")" = "0" ] && ! [ "$(eval printf "%s" "\$$inhouse_option_name")" = "1" ]; then
	__emsg "$(__get_localized ERR_006)" "$inhouse_option_name"
	exit 1
fi
eval type="100\$$inhouse_option_name"
hostname="$HW.$hostbase"
nonce=$(dd if=/dev/urandom bs=16 count=1 2>/dev/null | base64)
eval $version_name="$version_string"
#######################################################################################################
#                                                                                                     #
# show debug info regarding final variable content                                                    #
#                                                                                                     #
#######################################################################################################
if __is_debug; then
	names="$(get_names "$common_names" "$alt_names" 2) $flags_name $inhouse_option_name"
	__debug "$delimiter_line"
	__debug "$(__get_localized DBG_003)"
	__debug "$delimiter_line"
	for n in $names type hostname nonce; do
		__debug "%s=\"%s\"\n" "$n" "$(eval printf "%s" \"\$$n\")"
	done
	__debug "$delimiter_line"
fi
#######################################################################################################
#                                                                                                     #
# prepare temporary files for the check request                                                       #
#                                                                                                     #
#######################################################################################################
body="$(mktmp -p "$td")"
header="$(mktmp -p "$td")"
response="$(mktmp -p "$td")"
printf "$body_tmpl" "$nonce" "$Name" "$HW" "$Major" "$Minor" "$Patch" "$Buildnumber" "$type" "$Serial" "$OEM" "$Lang" "$Country" "$Annex" | \
	sed -e "s|\t|  |g" >>"$body"
len=$(stat -c %s "$body")
printf "$headerline_0" "$juisurl" >>"$header"
printf "$headerline_1" "$hostname" "$juisport" >>"$header"
printf "$headerline_2" $len >>"$header"
printf "$headerline_3" "$contenttype" >>"$header"
printf "$headerline_4" >>"$header"
if __is_debug; then
	__debug "$(__get_localized DBG_004)" 
	__debug "$delimiter_line"
	sed -e "s|^|       |" "$header" 1>&2
	printf "\r\n" 1>&2
	sed -e "s|^|       |" "$body" 1>&2
	__debug "$delimiter_line"
fi
#######################################################################################################
#                                                                                                     #
# execute SOAP request                                                                                #
#                                                                                                     #
#######################################################################################################
__debug "$(__get_localized DBG_008)" "$hostname" "$juisport"
( cat "$header"; printf "\r\n"; cat "$body" ) | tcp_read "$hostname" "$juisport" "$response" "$remote_timeout"
if __is_debug; then
	__debug "$(__get_localized DBG_005)"
	__debug "$delimiter_line"
	sed -e "s|^|       |" "$response" 1>&2
	printf "\n" 1>&2
	__debug "$delimiter_line"
fi
#######################################################################################################
#                                                                                                     #
# examine the status code                                                                             #
#                                                                                                     #
#######################################################################################################
status="$(sed -n -e "1p" "$response" | sed -n -e "s|HTTP/1.1 \([0-9]*\) OK.*|\1|p")"
if [ -z "$status" ]; then
	__emsg "$(__get_localized ERR_007)"
	exit 4
elif ! [ "$status" = "200" ]; then
	__emsg "$(__get_localized ERR_008)" "$status" "$hostname"
	exit 4
fi
#######################################################################################################
#                                                                                                     #
# examine the response and show the result                                                            #
#                                                                                                     #
#######################################################################################################
xmlresp="$(mktmp -p "$td")"
sed -n -e "\$p" "$response" >"$xmlresp"
found="$(extract_xml "$xmlresp" "ns3" "Found")"
if ! [ "$found" = "true" ]; then
	__emsg "$(__get_localized ERR_009)" "$Version"
	exit 2
fi
URL="$(extract_xml "$xmlresp" "ns3" "DownloadURL")"
delay="$(sed -n -e "s|^Download-Delay: \([0-9]*\)|\1|p" "$response")"
Version="$(extract_xml "$xmlresp" "ns3" "Version")"
__info "$(__get_localized INF_001)" "$Version" 1>&2
printf "URL=%s\n" "$URL"
[ -z "$delay" ] || printf "DelayDownload=%s\n" "$delay"
#######################################################################################################
#                                                                                                     #
# end of script                                                                                       #
#                                                                                                     #
#######################################################################################################
exit 0
